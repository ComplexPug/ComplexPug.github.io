# Lecture 01
## 前置
搭建环境，又复习了一下gdb。
## test xv6 in qemu
感觉十分简陋，有一些小工具ls，grep，管道等。
## 1.7 Shell
文件描述符本质上对应了内核中的一个表单数据。内核维护了每个运行进程的状态，内核会为每一个运行进程保存一个表单，表单的key是文件描述符。这个表单让内核知道，每个文件描述符对应的实际内容是什么。这里比较关键的点是，每个进程都有自己独立的文件描述符空间，所以如果运行了两个不同的程序，对应两个不同的进程，如果它们都打开一个文件，它们或许可以得到相同数字的文件描述符，但是因为内核为每个进程都维护了一个独立的文件描述符空间，这里相同数字的文件描述符可能会对应到不同的文件。

- [ ] 问题：为什么这样设计呢。

## 1.8 fork系统调用
进程调用fork()。fork()出来的进程返回0，另一个返回PID。
新进程从fork()开始执行。

- [ ] 学生提问：fork产生的子进程是不是总是与父进程是一样的？它们有可能不一样吗？
Robert教授：在XV6中，除了fork的返回值，两个进程是一样的。两个进程的指令是一样的，数据是一样的，栈是一样的，同时，两个进程又有各自独立的地址空间，它们都认为自己的内存从0开始增长，但这里是不同的内存。 在一个更加复杂的操作系统，有一些细节我们现在并不关心，这些细节偶尔会导致父子进程不一致，但是在XV6中，父子进程除了fork的返回值，其他都是一样的。除了内存是一样的以外，文件描述符的表单也从父进程拷贝到子进程。所以如果父进程打开了一个文件，子进程可以看到同一个文件描述符，尽管子进程看到的是一个文件描述符的表单的拷贝。除了拷贝内存以外，fork还会拷贝文件描述符表单这一点还挺重要的，我们接下来会看到。
- [ ] 对上面一个问题：文件描述符的拷贝和文件描述符又有什么区别呢。那他们的PID不是不一样吗

## 1.9 exec, wait系统调用

## 1.10 I/O Redirect

## Lab1

### sleep.c

## Problems
> 编译器是如何处理系统调用的（如open，read/write file）
调用相关的指令转到内核态处理